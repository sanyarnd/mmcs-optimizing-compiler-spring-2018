### Название задачи
Свёртка констант, протяжка констант

#### Постановка задачи
Создать класс, реализующий итерационный алгоритм для задачи распостронения констант

#### Зависимости задач в графе задач
Зависит от:
- Общий итерационный алгоритм
- Передаточная функция для задачи распостронения констант

#### Теоретическая часть задачи
Распространение констант – хорошо известная проблема глобального анализа потока данных. Цель распространения констант состоит в обнаружении величин, которые являются постоянными при любом возможном пути выполнения программы, и в распространении этих величин так далеко по тексту программы, как только это возможно. Выражения, чьи операнды являются константами, могут быть вычислены на этапе компиляции. Поэтому использование алгоритмов распространения констант позволяет компилятору выдавать более компактный и быстрый код.

Рассмотрим следующий пример:

int x = 14;
int y = 7 - x / 2;
return y * (28 / x + 2);

Распространение x возвращает:

int x = 14;
int y = 7 - 14 / 2;
return y * (28 / 14 + 2);

Далее, свёртка констант и распространение y возвращают следующее:

int x = 14;
int y = 0;
return 0;


#### Практическая часть задачи (реализация)
Был реализован класс `ConstantPropagation`.

```
public class ConstantPropagation : IOptimization
	{
		public List<Node> Optimize(List<Node> nodes, out bool applied)
		{
			var app = false;
			for (int i = 0; i < nodes.Count; i++)
			{
				if (nodes[i] is Assign node && node.Operation == OpCode.Copy && node.Right is IntConst)
				{
					for (int j = i + 1; j < nodes.Count; j++)
					{
						if (nodes[j] is Assign nextNode)
						{
							//Если мы встретили объявление этого же элемента
							if (node.Result.Equals(nextNode.Result))
								break;
							//Проверка использования Result в левом операнде другого узла
							if (node.Result.Equals(nextNode.Left))
							{
								nextNode.Left = node.Right;
								nodes[j] = nextNode;
								app = true;
							}
							//Проверка использования Result в правом операнде другого узла
							if (node.Result.Equals(nextNode.Right))
							{
								nextNode.Right = node.Right;
								nodes[j] = nextNode;
								app = true;
							}
						}
					}
				}
			}
			applied = app;
			return nodes;
		}
	}
```
#### Тесты
Короткие примеры, демонстрирующие правильность.

#### Пример работы.
Большой пример, демонстрирующий алгоритм.
